
import scipy.stats as stats
import seaborn as sns
## we decided to use the adjusted closing price at time t as the value of Pt

KO = yf.download("KO", start="1989-12-31", end="2024-12-31")

# Extract daily log returns (log_rt_dy = log_returns daily)
log_price_daily = np.log(KO['Close'])
log_rt_dy = log_price_daily.diff().dropna().squeeze()# or np.log(KO['Close'] / KO['Close'].shift(1))

# Calculate monthly log-returns (log_returns_monthly = log_rt_m)
log_price_monthly = np.log(KO['Close']).resample('ME').last().squeeze()
log_rt_m = log_price_monthly.diff().dropna().squeeze()

# Calculate annual Log-returns (remove the first obs which is a NaN) (log_returns_annual = log_rt_y)
annual_log_price = np.log(KO['Close']).resample('YE').last().squeeze() # Resample data to annual frequency
log_rt_y = annual_log_price.diff().dropna().squeeze()





import numpy as np
import pandas as pd
from scipy.stats import skew, kurtosis, jarque_bera
from statsmodels.stats.diagnostic import lilliefors

# Dictionary of log return series
X = {
    'daily': log_rt_dy,
    'monthly': log_rt_m,
    'annual': log_rt_y
}

# Define statistics function
def multi_fun(x):
    x = x.dropna().values  # ensure numpy array
    n = len(x)
    stat_tab = {
        'Mean': (np.mean(x) * 100,5),
        'St.Deviation': (np.std(x) * 100,5),
        'Diameter.C.I.Mean': (1.96 * np.sqrt(np.var(x) / n) * 100,5),
        'Skewness': (skew(x),5),
        'Kurtosis': (kurtosis(x),5),
        'Excess.Kurtosis': (kurtosis(x) - 3,5),
        'Min': (np.min(x) * 100,5),
        'Quant5': (np.quantile(x, 0.05) * 100,5),
        'Quant25': (np.quantile(x, 0.25) * 100,5),
        'Median': (np.quantile(x, 0.50) * 100,5),
        'Quant75': (np.quantile(x, 0.75) * 100,5),
        'Quant95': (np.quantile(x, 0.95) * 100,5),
        'Max': (np.max(x) * 100,5),
        'Jarque.Bera.stat': (jarque_bera(x)[0],5),
        'Jarque.Bera.pvalue.X100': (jarque_bera(x)[1]*100,5),
        'Lillie.test.stat': round(lilliefors(x)[0],5),
        'Lillie.test.pvalue.X100': round(lilliefors(x)[1] * 100,5),
        'N.obs': len(x)
    }
    return stat_tab



statistics_dict = {}

# Apply function to each frequency
statistics_dict = {
    key: multi_fun(data.iloc[1:]) 
    for key, data in X.items()
}
# apply multi_fun to each returns ("series" in pandas) 
# which is located in one of the four key of our dictionary X 

# Create a Data Frame
statistics_df = pd.DataFrame(statistics_dict)

# print
print(statistics_df),

pd.set_option('display.max_columns', None)  # montre toutes les colonnes
pd.set_option('display.width', 120)         # élargit la table pour éviter les coupures
pd.set_option('display.float_format', '{:.4f}'.format)  # 4 décimales cohérentes


display(statistics_df.style.set_caption("Summary Statistics of Returns (Daily, Weekly, Monthly, Annual)")
         .set_table_styles([
             {'selector': 'caption',
              'props': [('font-size', '16px'),
                        ('text-align', 'center'),
                        ('color', '#2F4F4F'),
                        ('font-weight', 'bold'),
                        ('padding', '10px')]},
             {'selector': 'th',
              'props': [('background-color', '#D3D3D3'),
                        ('color', 'black'),
                        ('font-weight', 'bold'),
                        ('border', '1px solid black'),
                        ('text-align', 'center')]},
             {'selector': 'td',
              'props': [('border', '1px solid black'),
                        ('text-align', 'center'),
                        ('padding', '5px')]},
         ]))






